#include <assert.h>
#include <munit.h>
#include <stddef.h>
#include <string.h>
#include <wmmintrin.h>

#include "aes-ni.h"
#include <hexdump.h>

#define m128i_eq(a, b) (_mm_movemask_epi8(_mm_cmpeq_epi8((a), (b))) == 0xffff)

static MunitResult test_aes128_ecb(const MunitParameter params[],
                                   void *user_data_or_fixture) {
  const unsigned char key[16] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
                                 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
                                 0x0c, 0x0d, 0x0e, 0x0f};
  const unsigned char plain_text[16] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
                                        0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb,
                                        0xcc, 0xdd, 0xee, 0xff};
  const unsigned char expected_cipher_text[16] = {
      0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30,
      0xd8, 0xcd, 0xb7, 0x80, 0x70, 0xb4, 0xc5, 0x5a};
  unsigned char actual_cipher_text[16];

  AesContext ctx;
  aesni_init(&ctx, 128, key);
  aesni_ecb_encrypt(&ctx, 16, actual_cipher_text, plain_text);
  munit_assert_memory_equal(16, expected_cipher_text, actual_cipher_text);

  unsigned char actual_dec_text[16];
  aesni_init(&ctx, 128, key);
  aesni_ecb_decrypt(&ctx, 16, actual_dec_text, actual_cipher_text);
  munit_assert_memory_equal(16, actual_dec_text, plain_text);

  return MUNIT_OK;
}

static MunitResult test_aes192_ecb(const MunitParameter params[],
                                   void *user_data_or_fixture) {
  unsigned char key[24] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                           0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                           0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17};
  unsigned char plain_text[16] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
                                  0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb,
                                  0xcc, 0xdd, 0xee, 0xff};
  unsigned char cipher_text[16];
  unsigned char expected_cipher_text[16] = {0xdd, 0xa9, 0x7c, 0xa4, 0x86, 0x4c,
                                            0xdf, 0xe0, 0x6e, 0xaf, 0x70, 0xa0,
                                            0xec, 0x0d, 0x71, 0x91};
  AesContext ctx;
  aesni_init(&ctx, 192, key);
  aesni_ecb_encrypt(&ctx, 16, cipher_text, plain_text);
  munit_assert_memory_equal(16, expected_cipher_text, cipher_text);

  unsigned char dec_text[16];
  const unsigned char expected_dec_text[16] = {
      0,    0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
      0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
  aesni_init(&ctx, 192, key);
  aesni_ecb_decrypt(&ctx, 16, dec_text, cipher_text);
  munit_assert_memory_equal(16, dec_text, expected_dec_text);

  __m128i expected_dec_ks[13] = {
      _mm_setr_epi8(0xa4, 0x97, 0xa, 0x33, 0x1a, 0x78, 0xdc, 0x9, 0xc4, 0x18,
                    0xc2, 0x71, 0xe3, 0xa4, 0x1d, 0x5d),
      _mm_setr_epi8(0xd6, 0xbe, 0xbd, 0xd, 0xc2, 0x9, 0xea, 0x49, 0x4d, 0xb0,
                    0x73, 0x80, 0x3e, 0x2, 0x1b, 0xb9),
      _mm_setr_epi8(0x8f, 0xb9, 0x99, 0xc9, 0x73, 0xb2, 0x68, 0x39, 0xc7, 0xf9,
                    0xd8, 0x9d, 0x85, 0xc6, 0x8c, 0x72),
      _mm_setr_epi8(0xf7, 0x7d, 0x6e, 0xc1, 0x42, 0x3f, 0x54, 0xef, 0x53, 0x78,
                    0x31, 0x7f, 0x14, 0xb7, 0x57, 0x44),
      _mm_setr_epi8(0x11, 0x47, 0x65, 0x90, 0x47, 0xcf, 0x66, 0x3b, 0x9b, 0xe,
                    0xce, 0x8d, 0xfc, 0xb, 0xf1, 0xf0),
      _mm_setr_epi8(0xdc, 0xc1, 0xa8, 0xb6, 0x67, 0x5, 0x3f, 0x7d, 0xcc, 0x5c,
                    0x19, 0x4a, 0xb5, 0x42, 0x3a, 0x2e),
      _mm_setr_epi8(0xc6, 0xde, 0xb0, 0xab, 0x79, 0x1e, 0x23, 0x64, 0xa4, 0x5,
                    0x5f, 0xbe, 0x56, 0x88, 0x3, 0xab),
      _mm_setr_epi8(0xdd, 0x1b, 0x7c, 0xda, 0xf2, 0x8d, 0x5c, 0x15, 0x8a, 0x49,
                    0xab, 0x1d, 0xbb, 0xc4, 0x97, 0xcb),
      _mm_setr_epi8(0x78, 0xc4, 0xf7, 0x8, 0x31, 0x8d, 0x3c, 0xd6, 0x96, 0x55,
                    0xb7, 0x1, 0xbf, 0xc0, 0x93, 0xcf),
      _mm_setr_epi8(0x60, 0xdc, 0xef, 0x10, 0x29, 0x95, 0x24, 0xce, 0x62, 0xdb,
                    0xef, 0x15, 0x2f, 0x96, 0x20, 0xcf),
      _mm_setr_epi8(0x4b, 0x4e, 0xcb, 0xdb, 0x4d, 0x4d, 0xcf, 0xda, 0x57, 0x52,
                    0xd7, 0xc7, 0x49, 0x49, 0xcb, 0xde),
      _mm_setr_epi8(0x1a, 0x1f, 0x18, 0x1d, 0x1e, 0x1b, 0x1c, 0x19, 0x47, 0x42,
                    0xc7, 0xd7, 0x49, 0x49, 0xcb, 0xde),
      _mm_setr_epi8(0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb,
                    0xc, 0xd, 0xe, 0xf)};
  for (size_t i = 0; i < 13; ++i) {
    munit_assert(m128i_eq(_mm_loadu_si128(&((__m128i *)ctx.dec_round_keys)[i]),
                          expected_dec_ks[i]));
  }

  return MUNIT_OK;
}

static MunitResult test_aes256_ecb(const MunitParameter params[],
                                   void *user_data_or_fixture) {
  const unsigned char key[32] = {
      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
      0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
      0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};
  const unsigned char plain_text[16] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
                                        0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb,
                                        0xcc, 0xdd, 0xee, 0xff};
  const unsigned char expected_cipher_text[16] = {
      0x8e, 0xa2, 0xb7, 0xca, 0x51, 0x67, 0x45, 0xbf,
      0xea, 0xfc, 0x49, 0x90, 0x4b, 0x49, 0x60, 0x89};
  unsigned char cipher_text[16];
  AesContext ctx;

  aesni_init(&ctx, 256, key);
  aesni_ecb_encrypt(&ctx, 16, cipher_text, plain_text);
  munit_assert_memory_equal(16, cipher_text, expected_cipher_text);

  unsigned char a[16];
  aesni_ecb_decrypt(&ctx, 16, a, cipher_text);
  munit_assert_memory_equal(16, a, plain_text);

  return MUNIT_OK;
}

static MunitResult test_aes128_cbc(const MunitParameter params[],
                                   void *user_data_or_fixture) {
  /* From https://datatracker.ietf.org/doc/html/rfc3602#section-4 */
  /* Case #1 */
  const unsigned char key1[16] = {0x06, 0xa9, 0x21, 0x40, 0x36, 0xb8,
                                  0xa1, 0x5b, 0x51, 0x2e, 0x03, 0xd5,
                                  0x34, 0x12, 0x00, 0x06};
  const unsigned char iv1[16] = {0x3d, 0xaf, 0xba, 0x42, 0x9d, 0x9e,
                                 0xb4, 0x30, 0xb4, 0x22, 0xda, 0x80,
                                 0x2c, 0x9f, 0xac, 0x41};
  const unsigned char *plain_text1 = (const unsigned char *)"Single block msg";
  const unsigned char expected_cipher_text1[16] = {
      0xe3, 0x53, 0x77, 0x9c, 0x10, 0x79, 0xae, 0xb8,
      0x27, 0x08, 0x94, 0x2d, 0xbe, 0x77, 0x18, 0x1a};
  unsigned char actual_cipher_text1[16];
  unsigned char actual_plain_text1[16];
  AesContext ctx;

  aesni_init(&ctx, 128, key1);
  aesni_cbc_encrypt(&ctx, 16, actual_cipher_text1, plain_text1, iv1);
  munit_assert_memory_equal(16, actual_cipher_text1, expected_cipher_text1);

  aesni_cbc_decrypt(&ctx, 16, actual_plain_text1, actual_cipher_text1, iv1);
  munit_assert_memory_equal(16, actual_plain_text1, plain_text1);

  /* Case #2 */
  const unsigned char key2[16] = {0xc2, 0x86, 0x69, 0x6d, 0x88, 0x7c,
                                  0x9a, 0xa0, 0x61, 0x1b, 0xbb, 0x3e,
                                  0x20, 0x25, 0xa4, 0x5a};
  const unsigned char iv2[16] = {0x56, 0x2e, 0x17, 0x99, 0x6d, 0x09,
                                 0x3d, 0x28, 0xdd, 0xb3, 0xba, 0x69,
                                 0x5a, 0x2e, 0x6f, 0x58};
  const unsigned char plain_text2[32] = {
      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
      0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
      0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};
  const unsigned char expected_cipher_text2[32] = {
      0xd2, 0x96, 0xcd, 0x94, 0xc2, 0xcc, 0xcf, 0x8a, 0x3a, 0x86, 0x30,
      0x28, 0xb5, 0xe1, 0xdc, 0x0a, 0x75, 0x86, 0x60, 0x2d, 0x25, 0x3c,
      0xff, 0xf9, 0x1b, 0x82, 0x66, 0xbe, 0xa6, 0xd6, 0x1a, 0xb1};
  unsigned char actual_cipher_text2[32];
  unsigned char actual_plain_text2[32];

  aesni_init(&ctx, 128, key2);
  aesni_cbc_encrypt(&ctx, 32, actual_cipher_text2, plain_text2, iv2);
  munit_assert_memory_equal(32, actual_cipher_text2, expected_cipher_text2);

  aesni_cbc_decrypt(&ctx, 32, actual_plain_text2, actual_cipher_text2, iv2);
  munit_assert_memory_equal(32, actual_plain_text2, plain_text2);

  /* Case #3 */
  const unsigned char key3[16] = {0x6c, 0x3e, 0xa0, 0x47, 0x76, 0x30,
                                  0xce, 0x21, 0xa2, 0xce, 0x33, 0x4a,
                                  0xa7, 0x46, 0xc2, 0xcd};
  const unsigned char iv3[16] = {0xc7, 0x82, 0xdc, 0x4c, 0x09, 0x8c,
                                 0x66, 0xcb, 0xd9, 0xcd, 0x27, 0xd8,
                                 0x25, 0x68, 0x2c, 0x81};
  const unsigned char *plain_text3 =
      (const unsigned char *)"This is a 48-byte message (exactly 3 AES blocks)";
  const unsigned char expected_cipher_text3[48] = {
      0xd0, 0xa0, 0x2b, 0x38, 0x36, 0x45, 0x17, 0x53, 0xd4, 0x93, 0x66, 0x5d,
      0x33, 0xf0, 0xe8, 0x86, 0x2d, 0xea, 0x54, 0xcd, 0xb2, 0x93, 0xab, 0xc7,
      0x50, 0x69, 0x39, 0x27, 0x67, 0x72, 0xf8, 0xd5, 0x02, 0x1c, 0x19, 0x21,
      0x6b, 0xad, 0x52, 0x5c, 0x85, 0x79, 0x69, 0x5d, 0x83, 0xba, 0x26, 0x84};
  unsigned char actual_cipher_text3[48];
  unsigned char actual_plain_text3[48];

  aesni_init(&ctx, 128, key3);
  aesni_cbc_encrypt(&ctx, 48, actual_cipher_text3, plain_text3, iv3);
  munit_assert_memory_equal(48, actual_cipher_text3, expected_cipher_text3);

  aesni_cbc_decrypt(&ctx, 48, actual_plain_text3, actual_cipher_text3, iv3);
  munit_assert_memory_equal(48, actual_plain_text3, plain_text3);

  return MUNIT_OK;
}

static MunitResult test_aes128_ctr(const MunitParameter params[],
                                   void *user_data_or_fixture) {
  /* Test Vector #1 */
  const unsigned char key1[16] = {0xae, 0x68, 0x52, 0xf8, 0x12, 0x10,
                                  0x67, 0xcc, 0x4b, 0xf7, 0xa5, 0x76,
                                  0x55, 0x77, 0xf3, 0x9e};
  unsigned char iv1[16] = {0, 0, 0, 0x30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
  const unsigned char plain_text1[16] = {0x53, 0x69, 0x6e, 0x67, 0x6c, 0x65,
                                         0x20, 0x62, 0x6c, 0x6f, 0x63, 0x6b,
                                         0x20, 0x6d, 0x73, 0x67};
  const unsigned char expected_cipher_text1[16] = {
      0xE4, 0x09, 0x5D, 0x4F, 0xB7, 0xA7, 0xB3, 0x79,
      0x2D, 0x61, 0x75, 0xA3, 0x26, 0x13, 0x11, 0xB8};
  unsigned char actual_cipher_text1[16];
  AesContext ctx;

  aesni_init(&ctx, 128, key1);
  aesni_ctr_xcrypt(&ctx, sizeof actual_cipher_text1, actual_cipher_text1,
                   plain_text1, iv1, iv1);

  munit_assert_memory_equal(sizeof actual_cipher_text1, actual_cipher_text1,
                            expected_cipher_text1);

  const unsigned char expected_iv1[16] = {0, 0, 0, 0x30, 0, 0, 0, 0,
                                          0, 0, 0, 0,    0, 0, 0, 2};
  munit_assert_memory_equal(16, iv1, expected_iv1);

  /* Test Vector #2 */
  const unsigned char key2[16] = {0x7e, 0x24, 0x06, 0x78, 0x17, 0xfa,
                                  0xe0, 0xd7, 0x43, 0xd6, 0xce, 0x1f,
                                  0x32, 0x53, 0x91, 0x63};
  unsigned char iv2[16] = {0,    0x6c, 0xb6, 0xdb, 0xc0, 0x54, 0x3b, 0x59,
                           0xda, 0x48, 0xd9, 0x0b, 0,    0,    0,    1};
  const unsigned char plain_text2[32] = {
      0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    0x0A,
      0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
      0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F};
  unsigned char cipher_text2[32];

  aesni_init(&ctx, 128, key2);
  aesni_ctr_xcrypt(&ctx, sizeof cipher_text2, cipher_text2, plain_text2, iv2,
                   iv2);

  const unsigned char expected_cipher_text2[32] = {
      0x51, 0x04, 0xA1, 0x06, 0x16, 0x8A, 0x72, 0xD9, 0x79, 0x0D, 0x41,
      0xEE, 0x8E, 0xDA, 0xD3, 0x88, 0xEB, 0x2E, 0x1E, 0xFC, 0x46, 0xDA,
      0x57, 0xC8, 0xFC, 0xE6, 0x30, 0xDF, 0x91, 0x41, 0xBE, 0x28};
  munit_assert_memory_equal(sizeof cipher_text2, cipher_text2,
                            expected_cipher_text2);

  const unsigned char expected_iv2[16] = {0,    0x6c, 0xb6, 0xdb, 0xc0, 0x54,
                                          0x3b, 0x59, 0xda, 0x48, 0xd9, 0x0b,
                                          0,    0,    0,    3};
  munit_assert_memory_equal(sizeof iv2, iv2, expected_iv2);

  /* Test Vector #3 */
  const unsigned char key3[16] = {0x76, 0x91, 0xbe, 3,    0x5e, 0x50,
                                  0x20, 0xa8, 0xac, 0x6e, 0x61, 0x85,
                                  0x29, 0xf9, 0xa0, 0xdc};
  unsigned char iv3[16] = {0,    0xe0, 1,    0x7b, 0x27, 0x77, 0x7f, 0x3f,
                           0x4a, 0x17, 0x86, 0xf0, 0,    0,    0,    1};
  const unsigned char plain_text3[36] = {
      0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    0x0a, 0x0b,
      0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
      0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23};
  unsigned char cipher_text3[36];
  aesni_init(&ctx, 128, key3);
  aesni_ctr_xcrypt(&ctx, sizeof cipher_text3, cipher_text3, plain_text3, iv3,
                   iv3);

  const unsigned char expected_cipher_text3[36] = {
      0xc1, 0xcf, 0x48, 0xa8, 0x9f, 0x2f, 0xfd, 0xd9, 0xcf, 0x46, 0x52, 0xe9,
      0xef, 0xdb, 0x72, 0xd7, 0x45, 0x40, 0xa4, 0x2b, 0xde, 0x6d, 0x78, 0x36,
      0xd5, 0x9a, 0x5c, 0xea, 0xae, 0xf3, 0x10, 0x53, 0x25, 0xb2, 0x07, 0x2f};
  munit_assert_memory_equal(sizeof cipher_text3, cipher_text3,
                            expected_cipher_text3);

  const unsigned char expected_iv3[16] = {0,    0xe0, 1,    0x7b, 0x27, 0x77,
                                          0x7f, 0x3f, 0x4a, 0x17, 0x86, 0xf0,
                                          0,    0,    0,    3};
  munit_assert_memory_equal(sizeof iv3, iv3, expected_iv3);
  return MUNIT_OK;
}

static MunitResult test_aes192_ctr(const MunitParameter params[],
                                   void *user_data_or_fixture) {
  /* Test Vector #4 */
  const unsigned char key1[24] = {
      0x16, 0xaf, 0x5b, 0x14, 0x5f, 0xc9, 0xf5, 0x79, 0xc1, 0x75, 0xf9, 0x3e,
      0x3b, 0xfb, 0x0E, 0xed, 0x86, 0x3d, 0x06, 0xcc, 0xfd, 0xb7, 0x85, 0x15};
  unsigned char iv1[16] = {0,    0,    0,    0x48, 0x36, 0x73, 0x3c, 0x14,
                           0x7d, 0x6d, 0x93, 0xcb, 0,    0,    0,    1};
  const unsigned char plain_text1[16] = {0x53, 0x69, 0x6e, 0x67, 0x6c, 0x65,
                                         0x20, 0x62, 0x6c, 0x6f, 0x63, 0x6b,
                                         0x20, 0x6d, 0x73, 0x67};
  unsigned char cipher_text1[16];
  AesContext ctx;

  aesni_init(&ctx, 192, key1);
  aesni_ctr_xcrypt(&ctx, sizeof cipher_text1, cipher_text1, plain_text1, iv1,
                   iv1);

  const unsigned char expected_cipher_text1[16] = {
      0x4b, 0x55, 0x38, 0x4f, 0xe2, 0x59, 0xc9, 0xc8,
      0x4e, 0x79, 0x35, 0xa0, 3,    0xcb, 0xe9, 0x28};
  munit_assert_memory_equal(sizeof cipher_text1, cipher_text1,
                            expected_cipher_text1);

  /* Test Vector #5 */
  const unsigned char key2[24] = {
      0x7c, 0x5c, 0xb2, 0x40, 0x1b, 0x3d, 0xc3, 0x3c, 0x19, 0xe7, 0x34, 8,
      0x19, 0xe0, 0xf6, 0x9c, 0x67, 0x8c, 0x3d, 0xb8, 0xe6, 0xf6, 0xa9, 0x1a};
  unsigned char iv2[16] = {0,    0x96, 0xb0, 0x3b, 2, 0x0c, 0x6e, 0xad,
                           0xc2, 0xcb, 0x50, 0x0d, 0, 0,    0,    1};
  const unsigned char plain_text2[32] = {
      0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    0x0A,
      0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
      0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F};
  unsigned char cipher_text2[32];

  aesni_init(&ctx, 192, key2);
  aesni_ctr_xcrypt(&ctx, sizeof cipher_text2, cipher_text2, plain_text2, iv2,
                   iv2);

  const unsigned char expected_cipher_text2[32] = {
      0x45, 0x32, 0x43, 0xfc, 0x60, 0x9b, 0x23, 0x32, 0x7e, 0xdf, 0xaa,
      0xfa, 0x71, 0x31, 0xCD, 0x9F, 0x84, 0x90, 0x70, 0x1c, 0x5a, 0xd4,
      0xa7, 0x9c, 0xfc, 0x1f, 0xe0, 0xff, 0x42, 0xF4, 0xFB, 0};
  munit_assert_memory_equal(sizeof cipher_text2, cipher_text2,
                            expected_cipher_text2);

  const unsigned char expected_iv2[16] = {0,    0x96, 0xb0, 0x3b, 2,    0x0c,
                                          0x6e, 0xad, 0xc2, 0xcb, 0x50, 0x0d,
                                          0,    0,    0,    3};
  munit_assert_memory_equal(sizeof iv2, iv2, expected_iv2);

  /* Test Vector #6 */
  const unsigned char key3[24] = {
      2, 0xbf, 0x39, 0x1e, 0xe8, 0xec, 0xb1, 0x59, 0xb9, 0x59, 0x61, 0x7b,
      9, 0x65, 0x27, 0x9b, 0xf5, 0x9b, 0x60, 0xa7, 0x86, 0xd3, 0xe0, 0xfe};
  unsigned char iv3[16] = {0,    7,    0xbd, 0xfd, 0x5c, 0xbd, 0x60, 0x27,
                           0x8d, 0xcc, 9,    0x12, 0,    0,    0,    1};
  const unsigned char plain_text3[36] = {
      0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    0x0a, 0x0b,
      0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
      0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23};
  unsigned char cipher_text3[36];

  aesni_init(&ctx, 192, key3);
  aesni_ctr_xcrypt(&ctx, sizeof cipher_text3, cipher_text3, plain_text3, iv3,
                   iv3);

  const unsigned char expected_cipher_text3[36] = {
      0x96, 0x89, 0x3f, 0xc5, 0x5e, 0x5c, 0x72, 0x2F, 0x54, 0x0b, 0x7d, 0xd1,
      0xdd, 0xf7, 0xe7, 0x58, 0xd2, 0x88, 0xbc, 0x95, 0xc6, 0x91, 0x65, 0x88,
      0x45, 0x36, 0xc8, 0x11, 0x66, 0x2f, 0x21, 0x88, 0xab, 0xee, 0x09, 0x35};
  munit_assert_memory_equal(sizeof cipher_text3, cipher_text3,
                            expected_cipher_text3);

  const unsigned char expected_iv3[16] = {0,    7,    0xbd, 0xfd, 0x5c, 0xbd,
                                          0x60, 0x27, 0x8d, 0xcc, 9,    0x12,
                                          0,    0,    0,    3};
  munit_assert_memory_equal(sizeof iv3, iv3, expected_iv3);

  return MUNIT_OK;
}

static MunitResult test_aes256_ctr(const MunitParameter params[],
                                   void *user_data_or_fixture) {
  /* Test Vector #7 */
  const unsigned char key1[32] = {
      0x77, 0x6b, 0xef, 0xf2, 0x85, 0x1d, 0xb0, 0x6f, 0x4c, 0x8a, 0x05,
      0x42, 0xc8, 0x69, 0x6f, 0x6c, 0x6a, 0x81, 0xaf, 0x1e, 0xec, 0x96,
      0xb4, 0xd3, 0x7f, 0xc1, 0xd6, 0x89, 0xe6, 0xc1, 0xc1, 0x04};
  unsigned char iv1[16] = {0,    0,    0,    0x60, 0xdb, 0x56, 0x72, 0xc9,
                           0x7a, 0xa8, 0xf0, 0xb2, 0,    0,    0,    1};
  const unsigned char plain_text1[16] = {0x53, 0x69, 0x6e, 0x67, 0x6c, 0x65,
                                         0x20, 0x62, 0x6c, 0x6f, 0x63, 0x6b,
                                         0x20, 0x6d, 0x73, 0x67};
  unsigned char cipher_text1[16];
  struct AesContext ctx;

  aesni_init(&ctx, 256, key1);
  aesni_ctr_xcrypt(&ctx, sizeof cipher_text1, cipher_text1, plain_text1, iv1,
                   iv1);

  const unsigned char expected_cipher_text1[16] = {
      0x14, 0x5a, 0xd0, 0x1d, 0xbf, 0x82, 0x4e, 0xc7,
      0x56, 0x08, 0x63, 0xdc, 0x71, 0xe3, 0xe0, 0xc0};
  munit_assert_memory_equal(sizeof cipher_text1, cipher_text1,
                            expected_cipher_text1);

  const unsigned char expected_iv1[16] = {0,    0,    0,    0x60, 0xdb, 0x56,
                                          0x72, 0xc9, 0x7a, 0xa8, 0xf0, 0xb2,
                                          0,    0,    0,    2};
  munit_assert_memory_equal(sizeof iv1, iv1, expected_iv1);

  /* Test Vector #8 */
  const unsigned char key2[32] = {
      0xf6, 0xd6, 0x6d, 0x6b, 0xd5, 0x2d, 0x59, 0xbb, 0x07, 0x96, 0x36,
      0x58, 0x79, 0xef, 0xf8, 0x86, 0xc6, 0x6d, 0xd5, 0x1a, 0x5b, 0x6a,
      0x99, 0x74, 0x4b, 0x50, 0x59, 0x0c, 0x87, 0xa2, 0x38, 0x84};
  unsigned char iv2[16] = {0,    0xfa, 0xac, 0x24, 0xc1, 0x58, 0x5e, 0xf1,
                           0x5a, 0x43, 0xd8, 0x75, 0,    0,    0,    1};
  const unsigned char plain_text2[32] = {
      0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    0x0A,
      0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
      0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F};
  unsigned char cipher_text2[32];

  aesni_init(&ctx, 256, key2);
  aesni_ctr_xcrypt(&ctx, sizeof cipher_text2, cipher_text2, plain_text2, iv2,
                   iv2);

  const unsigned char expected_cipher_text2[32] = {
      0xf0, 0x5e, 0x23, 0x1b, 0x38, 0x94, 0x61, 0x2c, 0x49, 0xee, 0,
      0x0b, 0x80, 0x4e, 0xb2, 0xa9, 0xb8, 0x30, 0x6b, 0x50, 0x8f, 0x83,
      0x9d, 0x6a, 0x55, 0x30, 0x83, 0x1d, 0x93, 0x44, 0xaf, 0x1c};
  munit_assert_memory_equal(sizeof cipher_text2, cipher_text2,
                            expected_cipher_text2);

  const unsigned char expected_iv2[16] = {0,    0xfa, 0xac, 0x24, 0xc1, 0x58,
                                          0x5e, 0xf1, 0x5a, 0x43, 0xd8, 0x75,
                                          0,    0,    0,    3};
  munit_assert_memory_equal(sizeof iv2, iv2, expected_iv2);

  /* Test Vector #9 */
  const unsigned char key3[32] = {
      0xff, 0x7a, 0x61, 0x7c, 0xe6, 0x91, 0x48, 0xe4, 0xf1, 0x72, 0x6e,
      0x2f, 0x43, 0x58, 0x1d, 0xe2, 0xaa, 0x62, 0xd9, 0xf8, 5,    0x53,
      0x2e, 0xdf, 0xf1, 0xee, 0xd6, 0x87, 0xfb, 0x54, 0x15, 0x3d};
  unsigned char iv3[16] = {0,    0x1c, 0xc5, 0xb7, 0x51, 0xa5, 0x1d, 0x70,
                           0xa1, 0xc1, 0x11, 0x48, 0,    0,    0,    1};
  const unsigned char plain_text3[36] = {
      0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    0x0a, 0x0b,
      0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
      0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23};
  unsigned char cipher_text3[36];

  aesni_init(&ctx, 256, key3);
  aesni_ctr_xcrypt(&ctx, sizeof cipher_text3, cipher_text3, plain_text3, iv3,
                   iv3);

  const unsigned char expected_cipher_text3[36] = {
      0xeb, 0x6c, 0x52, 0x82, 0x1d, 0x0b, 0xbb, 0xf7, 0xce, 0x75, 0x94, 0x46,
      0x2a, 0xca, 0x4f, 0xaa, 0xb4, 7,    0xdf, 0x86, 0x65, 0x69, 0xfd, 7,
      0xf4, 0x8c, 0xc0, 0xb5, 0x83, 0xd6, 7,    0x1f, 0x1e, 0xc0, 0xe6, 0xb8};
  munit_assert_memory_equal(sizeof cipher_text3, cipher_text3,
                            expected_cipher_text3);

  const unsigned char expected_iv3[16] = {0,    0x1c, 0xc5, 0xb7, 0x51, 0xa5,
                                          0x1d, 0x70, 0xa1, 0xc1, 0x11, 0x48,
                                          0,    0,    0,    3};
  munit_assert_memory_equal(sizeof iv3, iv3, expected_iv3);

  return MUNIT_OK;
}

static MunitTest tests[] = {
    {
        "/aes-128-ecb",         /* name */
        test_aes128_ecb,        /* test */
        NULL,                   /* setup */
        NULL,                   /* tear_down */
        MUNIT_TEST_OPTION_NONE, /* options */
        NULL                    /* parameters */
    },
    {"/aes-192-ecb", test_aes192_ecb, NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL},
    {"/aes-256-ecb", test_aes256_ecb, NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL},
    {"/aes-128-cbc", test_aes128_cbc, NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL},
    {"/aes-128-ctr", test_aes128_ctr, NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL},
    {"/aes-192-ctr", test_aes192_ctr, NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL},
    {"/aes-256-ctr", test_aes256_ctr, NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL},
    /* Mark the end of the array with an entry where the test
     * function is NULL */
    {NULL, NULL, NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL}};

static const MunitSuite suite = {
    "/aes-ni",              /* name */
    tests,                  /* tests */
    NULL,                   /* suites */
    1,                      /* iterations */
    MUNIT_SUITE_OPTION_NONE /* options */
};

int main(int argc, char *argv[]) {
  return munit_suite_main(&suite, NULL, argc, argv);
}
